# ---

## title: "Exam 2 Summary Sheet"

# 1. Missing Data

#### **Explicit missing data**: `NA`.

1.  **Drop** the cases or rows with any missing data from the analysis
2.  **Create** a category for missing values.
3.  **Impute** (or fill in values for) the missing data using imputation algorithms.

#### **Implicit missing data** is data that is missing but not explicitly marked as such. (eg. entire row missing)

**Make implicit missingness explicit** before we can work with the data.

-   If a combination is missing, you can create a new row with explicit missing values.
    -   `complete()`

        eg.

        ```{r}
        study_data_full <- study_data |> 
          complete(pid, visit)
        ```

## Missing Data Mechanisms

-   **Missing completely at random (MCAR)**:
    -   The probability of missing data for a variable is the same for all cases. Implies that causes of the missing data are unrelated to the data.

<!-- -->

-   **Missing at random (MAR):**
    -   The probability of missing data is related to **observed** variables but unrelated to unobserved information.

<!-- -->

-   **Missing not at random (MNAR):**
    -   The probability of missing data is related to **unobserved** variables (and probably observed variables too).

**Explore Missingness:**

```{r, eval=FALSE}
naniar::vis_miss() 

naniar::miss_var_summary()
```

**Simulate Missing Data:**

Single Inputation

```{r, eval=FALSE}
rnorm(n, mean, sd) #generates random numbers from a normal (or Gaussian) distribution
rbinom(n, size, prob) #used to generate random numbers from a binomial distribution
```

multiple Inputation

```{r, eval = FALSE}
mice() #Multivariate Imputation by Chained Equations (MICE)
```

# 2. Function

## **Define Function**

```{r, eval = FALSE}
function_name <- function(input_name_1, input_name_2 = default_value_2){

  # function body - code that does something

  return(output)
}

# Calling a function (all valid ways)
function_name(input_name_1 = 2, input_name_2 = 4)
function_name(2, 4)
function_name(input_name_2 = 4, input_name_1 = 2)
function_name(2)
```

The core parts of defining a function include:

-   **`function()` directive**
-   **Arguments/Inputs**
-   **Function body**
    -   The code inside the curly braces `{ }`
-   **Return value**

<!-- -->

-   If we don't provide a `return()`, the last value that gets evaluated in the **function body** and isn't stored as an object is what the function returns.

## Scope

The area of a program where a named object is recognized and can be used

**Lexical scope:** The scope of a variable is determined by where it is created in the code

-   When code refers to an object (e.g. data set, function, vector, etc.), R looks for the object in the current, **local environment**.
-   **parent environment** –\> **global environment –\> loaded packages**

## Tips of Writing Function

-   **Body of the function** (the task that you are wanting to repeat)
-   **Identify the parts of the function that could/would change** (these are the **inputs**)
    -   Update the body of the function to be in terms of the inputs
    -   Avoid manually typing anything that is specific to one input; use code to get that (such as unique values of a variable)
-   **Identify the output you want to return**

## The `if-else if-else` Control Structure

```{r, eval = FALSE}
if (logical_condition) {
    # some code
} else if (other_logical_condition) {
    # some code
} else {
    # some code
}
```

::: {.callout-tip title="To vectorize or not to vectorize"}
The `if () else {}` code is not **vectorized**; the logical condition in `if()` cannot be a logical vector of length longer than 1.
:::

# 3. Base R

## Common R Object Structures

**Vector**: A vector is a **collection of elements** of the **same type** (e.g., numeric, integer, character, logical).

**List**: A list is a collection of elements (e.g., vectors, matrices, data frames, other lists).

-   A list can have different types of elements.
-   A list can have names for its elements.

**Array**: An array is a **vector** with a dimension attribute.

-   Like a vector, an array can only have one type of data (e.g., numeric, character).

**Matrix**: A matrix is an **array** with only 2 dimensions (rows, columns).

-   Like a vector, a matrix can only have one type of data (e.g., numeric, character).

**Data Frame/tibble**: A data frame is a named **list** with **elements** of equal length.

-   Each element is a "column" in the data frame.
-   The columns can be of different types (e.g., character, numeric, logical, lists, etc.).
-   Data frames are the most common way to store data in R.
-   [Tibbles do less and complain more than base data.frames](https://tibble.tidyverse.org/reference/tbl_df-class.html)

## Base R Subsetting

### Selecting elements with `[]`

1.  **A vector of positive integers** (vectors; lists)
2.  **A vector of negative integers**.

```{r, eval = FALSE}
x[c(-1, -3, -5)]
# -1指的是正数第二个index
```

3.  **A logical vector**. (`filter()` removes instances of missing values by default.)

```{r, eval = FALSE}
y <- list(a = 1:3, b = c("a", "b", "c"), c = matrix(1:6, nrow = 2))
y[y |> map_lgl(~ is.numeric(.x))]
```

4.  **A character vector**

    ```{r, eval = FALSE}
    # Named Vector
    x <- c(abc = 1, def = 2, xyz = 5)
    x[c("xyz", "def")]
    x[c("xyz","xyz","xyz", "def")]

    #Named List
    y[c('a','a','c')]
    # indicating indexes
    ```

## Subsetting Matricies and Data Frames with `[ ]`

```{r}
m <- matrix(1:12, nrow = 3, ncol = 4)
m

m[1:5] # Matrix = vector (down the columns) with dimensions
```

```{r}
m[1,] # Get 1st row
m[,1] # Get 1st column
m[1,3] # Get 1st row and 3rd column
m[-1,] # Get all rows except 1st
m[c(TRUE, FALSE, FALSE),] # Get the 1st row via a logical
```

## Selecting a single element with `$` and `[[`

```{r}
mtcars
mtcars$mpg
mtcars[["mpg"]]
mtcars |> pull(mpg)
```

## Debugging Strategies

-   `print()` and `cat()` to print out intermediate results and messages within a function.
    -   Examples: `print(x)`, `cat("The value of x is", x, "\n")`
-   `browser()` to pause the function at a certain point and interactively explore the environment.
-   `try()` to catch errors and print out a message when an error occurs.
-   Include `if else` statements within a function to ensure that you are passing the right type of input to a function. You can create you own custom error message with `stop()`

# DataBase

DataWarehouse: Base on **Relational** **(SQL) databases**

## Connecting to a database in R with `DBI`

The `DBI` package (**d**ata**b**ase **i**nterface) provides general tools for interacting with databases from R.

-   `DBI`: connect with an **in-process** database (`duckdb`), one that runs locally on your computer.

-   `duckdb_read_csv()`: store data directly into the `duckdb` database without first having to read it into R.

-   Set up a database connection with `dbConnect()` and initialize a temporary database with `duckdb()`:

    `{library(tidyverse)} library(DBI) library(duckdb) con <- DBI::dbConnect(duckdb::duckdb()) class(con)`

## SQL

a programming language to query or retrieve data from a relational database

### SQL with `dplyr`

**show_query():** translate from r to sql

**clauses:** `SELECT`, `FROM`, `WHERE`, `GROUP BY`, and `ORDER BY`
